from datetime import datetime
from token import OP
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field, ConfigDict
from pymongo import IndexModel, ASCENDING, DESCENDING
from beanie import PydanticObjectId
from typing import Optional as OptionalType


class EpisodicMemory(BaseModel):
    """
    Episodic memory document model

    Stores user's episodic memories, including event summaries, participants, topics, etc.
    Directly transferred from MemCell summaries.

    Note: EpisodicMemory is stored in KV-Storage only, not in MongoDB.
    - For MongoDB storage and queries, use EpisodicMemoryLite (contains only indexed fields)
    - EpisodicMemory contains all fields and is used as the complete data type
    - Soft delete, hard delete, and restore operations are managed through EpisodicMemoryLite in MongoDB
    """

    # ID field (managed by MongoDB through EpisodicMemoryLite)
    id: OptionalType[PydanticObjectId] = Field(default=None, description="Document ID, generated by MongoDB")

    # Audit fields (managed by AuditBase through EpisodicMemoryLite)
    created_at: OptionalType[datetime] = Field(default=None, description="Creation time")
    updated_at: OptionalType[datetime] = Field(default=None, description="Last update time")

    # Soft delete field (managed through EpisodicMemoryLite)
    deleted_at: OptionalType[datetime] = Field(default=None, description="Soft delete time")

    user_id: Optional[str] = Field(
        default=None, description="The individual involved, None indicates group memory"
    )
    user_name: Optional[str] = Field(default=None, description="Name of the individual")
    group_id: Optional[str] = Field(default=None, description="Group ID")
    group_name: Optional[str] = Field(default=None, description="Group name")
    timestamp: datetime = Field(..., description="Occurrence time (timestamp)")
    participants: Optional[List[str]] = Field(
        default=None, description="Names of event participants"
    )
    summary: str = Field(..., min_length=1, description="Memory unit")
    subject: Optional[str] = Field(default=None, description="Memory unit subject")
    episode: str = Field(..., min_length=1, description="Episodic memory")
    type: Optional[str] = Field(
        default=None, description="Episode type, such as Conversation"
    )
    keywords: Optional[List[str]] = Field(default=None, description="Keywords")
    linked_entities: Optional[List[str]] = Field(
        default=None, description="Associated entity IDs"
    )

    memcell_event_id_list: Optional[List[str]] = Field(
        default=None, description="Memory unit event ID"
    )

    parent_type: Optional[str] = Field(
        default=None, description="Parent memory type (e.g., memcell)"
    )
    parent_id: Optional[str] = Field(default=None, description="Parent memory ID")

    extend: Optional[Dict[str, Any]] = Field(
        default=None, description="Reserved extension field"
    )

    vector: Optional[List[float]] = Field(default=None, description="Text vector")
    vector_model: Optional[str] = Field(
        default=None, description="Vectorization model used"
    )

    model_config = ConfigDict(
        collection="episodic_memories",
        validate_assignment=True,
        json_encoders={datetime: lambda dt: dt.isoformat()},
        json_schema_extra={
            "example": {
                "user_id": "user_12345",
                "group_id": "group_work",
                "timestamp": 1701388800,
                "participants": ["Zhang San", "Li Si"],
                "summary": "Discussed project progress and next week's plan",
                "subject": "Project meeting",
                "episode": "Held a project progress discussion in the meeting room, confirmed next week's development task assignments",
                "type": "Conversation",
                "keywords": ["project", "progress", "meeting"],
                "linked_entities": ["proj_001", "task_123"],
                "extend": {"priority": "high", "location": "Meeting Room A"},
            }
        },
        extra="allow",
    )

    @property
    def event_id(self) -> Optional[PydanticObjectId]:
        return self.id
